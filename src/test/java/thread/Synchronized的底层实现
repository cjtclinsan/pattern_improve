JDK早期的时候，synchronized的底层实现是重量级的，重到每次都去操作系统内核中去申请锁，这造成synchronized效率非常低。
后来，经过改进有了锁升级的概念：
HotSpot是这么做的：第一个去访问某把锁的线程，比如sync（Object），来了之后先在这个Object的头文件markword上记录这个线程。
（如果只有第一个线程访问的时候实际上是没有给Object加锁的，在内部实现的时候，只是记录这个线程的ID(偏向锁)）。
偏向锁如果有线程竞争的话，就升级为自旋锁，概念就是如果有线程占着锁，就先不跑到CPU的就绪队列里，而是等着占用CPU，用一个while循环在循环
去看能不能获得锁，循环一定次数还不能抢到锁的话，就再禁行升级（默认10次，升级为重量级锁）
需要注意的是：并不是CAS的效率就一定比系统锁要好！需要分情况：
1、加锁代码执行时间短，线程数小，用自旋
2、代码执行时间长，线程数多，用系统锁

总结：
现成的概念、启动方式、常用方法
synchronized(Object) 不能用String常量，Integer，Long

线程同步-synchronized
1、所得不是代码，是对象
2、synchronized(this)   synchronized(XX.class)
3、锁定方法 非锁定方法  同时执行
4、锁升级
5、偏向锁  记录这个线程ID
6、自旋锁 如果线程争用，就升级为自旋锁
7、重量级锁 默认自旋10次升级